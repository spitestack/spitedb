/**
 * Generates HTTP handlers that wire aggregates to SpiteDB.
 */

import type { AggregateIR, CommandIR } from "../ir/index.js";
import { toSnakeCase, toPascalCase } from "./ts-types.js";

/**
 * Generates handlers for an aggregate.
 */
export function generateHandlers(aggregate: AggregateIR, domainImportPath: string): string {
  const snakeName = toSnakeCase(aggregate.name);
  const pascalName = toPascalCase(aggregate.name);

  const imports = `// Generated handlers for ${aggregate.name}
// DO NOT EDIT - this file is generated by spite-compiler

import type { SpiteDB } from "@spitestack/spitedb";
import { ${aggregate.name}Aggregate } from "${domainImportPath}/${snakeName}/aggregate.js";
import type { ${aggregate.name}State, ${aggregate.events.name} } from "${domainImportPath}/${snakeName}/index.js";
${aggregate.commands.map((cmd) =>
  `import { validate${toPascalCase(cmd.name)} } from "../validators/${snakeName}.validator.js";`
).join("\n")}`;

  const handlers = aggregate.commands.map((cmd) => generateCommandHandler(aggregate, cmd));

  const createHandlers = `
/**
 * Creates handlers for ${aggregate.name}.
 */
export function create${pascalName}Handlers(db: SpiteDB) {
  return {
${aggregate.commands.map((cmd) => `    ${cmd.name}: handle${toPascalCase(cmd.name)}`).join(",\n")}
  };
}`;

  return `${imports}

${handlers.join("\n\n")}
${createHandlers}
`;
}

/**
 * Generates a handler for a command.
 */
function generateCommandHandler(aggregate: AggregateIR, cmd: CommandIR): string {
  const pascalName = toPascalCase(cmd.name);
  const hasParams = cmd.parameters.length > 0;

  const roles = cmd.roles ?? [];
  const accessComment = cmd.access !== "internal"
    ? `// Access: ${cmd.access}${roles.length > 0 ? ` (roles: ${roles.join(", ")})` : ""}\n`
    : "";

  return `${accessComment}async function handle${pascalName}(
  streamId: string,
  ${hasParams ? "input: unknown," : ""}
  db: SpiteDB
): Promise<void> {
  ${hasParams ? `const validated = validate${pascalName}(input);` : ""}

  // Load aggregate from event store
  const events = await db.readStream<${aggregate.events.name}>(streamId);
  const aggregate = new ${aggregate.name}Aggregate();

  // Replay events
  for (const event of events) {
    aggregate.apply(event.data);
  }

  // Execute command
  ${hasParams
    ? `aggregate.${cmd.name}(${cmd.parameters.map((p) => `validated.${p.name}`).join(", ")});`
    : `aggregate.${cmd.name}();`}

  // Persist new events (captured by emit)
  // Note: In production, this would be handled by the runtime
}`;
}
