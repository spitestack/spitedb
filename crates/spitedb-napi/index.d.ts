/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Telemetry record kind. */
export const enum TelemetryKindNapi {
  Log = 'Log',
  Metric = 'Metric',
  Span = 'Span'
}
/** Metric aggregation semantics. */
export const enum MetricKindNapi {
  Gauge = 'Gauge',
  Counter = 'Counter',
  Histogram = 'Histogram',
  Summary = 'Summary'
}
/** Span status code. */
export const enum SpanStatusNapi {
  Unset = 'Unset',
  Ok = 'Ok',
  Error = 'Error'
}
/** Sort order for queries. */
export const enum TelemetryOrderNapi {
  Asc = 'Asc',
  Desc = 'Desc'
}
/** Time-slice policy. */
export const enum TimeSliceNapi {
  Daily = 'Daily'
}
/** Configuration for telemetry storage. */
export interface TelemetryConfigNapi {
  appName?: string
  partitions?: number
  batchMaxMs?: number
  batchMaxBytes?: number
  batchMaxRecords?: number
  maxInflight?: number
  retentionDays?: number
  timeSlice?: TimeSliceNapi
  defaultService?: string
}
/** Cursor for tailing a telemetry shard. */
export interface TelemetryCursorNapi {
  slice: string
  lastIds: Array<number>
}
/** Telemetry record payload for writes and reads. */
export interface TelemetryRecordNapi {
  tsMs: number
  kind: TelemetryKindNapi
  tenantId?: string
  tenantHash?: number
  eventGlobalPos?: number
  streamId?: string
  streamHash?: number
  streamRev?: number
  commandId?: string
  traceId?: string
  spanId?: string
  parentSpanId?: string
  name?: string
  service?: string
  severity?: number
  message?: string
  metricName?: string
  metricValue?: number
  metricKind?: MetricKindNapi
  metricUnit?: string
  spanStartMs?: number
  spanEndMs?: number
  spanDurationMs?: number
  spanStatus?: SpanStatusNapi
  attrsJson?: string
}
/** Query parameters for telemetry searches. */
export interface TelemetryQueryNapi {
  tenantId?: string
  tenantHash?: number
  kind?: TelemetryKindNapi
  startMs?: number
  endMs?: number
  severity?: number
  metricName?: string
  eventGlobalPos?: number
  streamId?: string
  streamHash?: number
  streamRev?: number
  commandId?: string
  traceId?: string
  limit?: number
  order?: TelemetryOrderNapi
  slice?: string
  shardId?: number
}
/** Result of a telemetry tail call. */
export interface TelemetryTailResultNapi {
  records: Array<TelemetryRecordNapi>
  cursor: TelemetryCursorNapi
}
/** Result of an append operation. */
export interface AppendResultNapi {
  /** First global position assigned */
  firstPos: number
  /** Last global position assigned */
  lastPos: number
  /** First stream revision assigned */
  firstRev: number
  /** Last stream revision assigned */
  lastRev: number
}
/** Append command payload for atomic transactions. */
export interface AppendCommandNapi {
  /** The stream to append to */
  streamId: string
  /** Unique command ID for idempotency */
  commandId: string
  /** Expected revision: -1 for "any", 0 for "stream must not exist", >0 for exact revision */
  expectedRev: number
  /** Array of event data buffers */
  events: Array<Buffer>
  /** Tenant ID (use DEFAULT_TENANT for single-tenant apps) */
  tenant: string
}
/** Append command payload for batch appends (tenant specified at batch level). */
export interface BatchAppendCommandNapi {
  /** The stream to append to */
  streamId: string
  /** Unique command ID for idempotency */
  commandId: string
  /** Expected revision: -1 for "any", 0 for "stream must not exist", >0 for exact revision */
  expectedRev: number
  /** Array of event data buffers */
  events: Array<Buffer>
}
/** SQL parameter for atomic transactions. */
export interface SqlParamNapi {
  /** Parameter type: "null", "integer", "real", "text", "blob", "bool" */
  kind: string
  /** String value (used for integer/real/text/bool) */
  value?: string
  /** Blob value (used for blob) */
  blob?: Buffer
}
/** SQL statement for atomic transactions. */
export interface SqlStatementNapi {
  /** SQL statement with ? placeholders */
  sql: string
  /** Parameters for the statement */
  params: Array<SqlParamNapi>
}
/** An event read from the store. */
export interface EventNapi {
  /** Global position in the log */
  globalPos: number
  /** Stream this event belongs to */
  streamId: string
  /** Tenant hash for this event */
  tenantHash: number
  /** Revision within the stream */
  streamRev: number
  /** Timestamp when stored (Unix milliseconds) */
  timestampMs: number
  /** Event payload */
  data: Buffer
}
/** A batch of events for projection processing. */
export interface EventBatchNapi {
  /** Name of the projection this batch is for */
  projectionName: string
  /** Events in the batch */
  events: Array<EventNapi>
  /** Batch ID for acknowledgment */
  batchId: number
}
/** Column definition for a projection schema. */
export interface ColumnDefNapi {
  /** Column name */
  name: string
  /** Column type: "text", "integer", "real", "blob", "boolean" */
  colType: string
  /** Whether this column is part of the primary key */
  primaryKey: boolean
  /** Whether this column allows NULL values */
  nullable: boolean
  /** Default value (as JSON string) */
  defaultValue?: string
}
/** A single projection operation. */
export interface ProjectionOpNapi {
  /** Operation type: "upsert" or "delete" */
  opType: string
  /** Primary key value */
  key: string
  /** Row values for upsert (JSON string) */
  value?: string
}
/** Result of processing a batch - operations to apply. */
export interface BatchResultNapi {
  /** Name of the projection */
  projectionName: string
  /** Tenant ID for all operations in this batch (framework-enforced) */
  tenantId: string
  /** Operations to apply */
  operations: Array<ProjectionOpNapi>
  /** Last global position processed (for checkpoint) */
  lastGlobalPos: number
}
/**
 * Admission control metrics snapshot.
 *
 * Provides visibility into the adaptive admission control system's state.
 */
export interface AdmissionMetricsNapi {
  /** Current max in-flight events (auto-adjusted based on observed latency) */
  currentLimit: number
  /** Observed p99 latency in milliseconds */
  observedP99Ms: number
  /** Target p99 latency in milliseconds (default: 60) */
  targetP99Ms: number
  /** Total requests that completed successfully */
  requestsAccepted: number
  /** Total requests that timed out due to backpressure */
  requestsRejected: number
  /** Ratio of rejected to total requests (0.0 to 1.0) */
  rejectionRate: number
  /** Number of times the controller adjusted the max_inflight limit */
  adjustments: number
}
export type SpiteDBNapi = SpiteDbNapi
/** NAPI wrapper for SpiteDB. */
export declare class SpiteDbNapi {
  /** Opens a SpiteDB database at the given path. */
  static open(path: string): Promise<SpiteDbNapi>
  /** Simple test method to verify NAPI exports work */
  testEcho(msg: string): string
  /**
   * Appends events to a stream.
   *
   * @param streamId - The stream to append to
   * @param commandId - Unique command ID for idempotency
   * @param expectedRev - Expected revision: -1 for "any", 0 for "stream must not exist", >0 for exact revision
   * @param events - Array of event data buffers
   * @param tenant - Tenant ID (use DEFAULT_TENANT for single-tenant apps)
   */
  append(streamId: string, commandId: string, expectedRev: number, events: Array<Buffer>, tenant: string): Promise<AppendResultNapi>
  /**
   * Executes an atomic transaction of appends with optional SQL statements.
   *
   * All commands must succeed; any conflict or duplicate aborts the transaction.
   */
  atomicTransaction(commands: Array<AppendCommandNapi>, sqlOps: Array<SqlStatementNapi>): Promise<Array<AppendResultNapi>>
  /**
   * Appends events to multiple streams atomically via batch fsync.
   *
   * All commands must succeed; any conflict or duplicate aborts the entire batch.
   * This is faster than atomicTransaction for multi-stream appends as it uses
   * batch fsync rather than immediate SQLite transactions.
   *
   * @param commands - Array of append commands, one per stream
   * @param tenant - Tenant ID (shared by all commands)
   */
  appendBatch(commands: Array<BatchAppendCommandNapi>, tenant: string): Promise<Array<AppendResultNapi>>
  /**
   * Appends events to a stream using a single JSON payload.
   *
   * This is optimized for Bun/Node.js - passing a single JSON string is faster
   * than passing arrays of Buffers through NAPI due to reduced marshalling overhead.
   *
   * @param payload - JSON string containing: { streamId, commandId, expectedRev, events, tenant }
   */
  appendStreamJson(payload: string): Promise<AppendResultNapi>
  /**
   * Appends events to multiple streams atomically using a single JSON payload.
   *
   * This is optimized for Bun/Node.js - passing a single JSON string is faster
   * than passing arrays of objects through NAPI due to reduced marshalling overhead.
   *
   * @param payload - JSON string containing: { commands: [{ streamId, commandId, expectedRev, events }], tenant }
   */
  appendBatchJson(payload: string): Promise<Array<AppendResultNapi>>
  /**
   * Reads events from a stream.
   *
   * @param streamId - The stream to read from
   * @param fromRev - Starting revision (0 for beginning)
   * @param limit - Maximum number of events to return
   * @param tenant - Tenant ID (use DEFAULT_TENANT for single-tenant apps)
   */
  readStream(streamId: string, fromRev: number, limit: number, tenant: string): Promise<Array<EventNapi>>
  /**
   * Reads events from the global log.
   *
   * @param fromPos - Starting position (0 or negative means "from beginning")
   * @param limit - Maximum number of events to return
   */
  readGlobal(fromPos: number, limit: number): Promise<Array<EventNapi>>
  /**
   * Gets the current revision of a stream.
   *
   * @param streamId - The stream to get revision for
   * @param tenant - Tenant ID (use DEFAULT_TENANT for single-tenant apps)
   */
  getStreamRevision(streamId: string, tenant: string): Promise<number>
  /**
   * Initializes the projection registry.
   *
   * @param projectionsDir - Directory where projection databases will be stored.
   *                         Each projection will have its own .db file in this directory.
   */
  initProjections(projectionsDir: string): Promise<void>
  /**
   * Registers a projection with the given schema.
   *
   * Creates the projection's database file at `{projectionsDir}/{name}.db`.
   * Tenant isolation is automatically enforced - a `tenant_id` column is
   * prepended to the schema and becomes part of the composite primary key.
   */
  registerProjection(name: string, schema: Array<ColumnDefNapi>): Promise<void>
  /**
   * Reads a row from a projection table by tenant_id and primary key (synchronous for proxy support).
   *
   * This method is synchronous because the magic proxy syntax (`table[key]`) requires
   * synchronous property access. The read uses blocking_lock internally.
   * Tenant isolation is enforced - only rows matching the tenant_id are returned.
   */
  readProjectionRow(projectionName: string, tenantId: string, key: string): string | null
  /**
   * Applies a batch of operations to a projection and updates the checkpoint.
   *
   * All operations in the batch must include tenant_id for tenant isolation.
   */
  applyProjectionBatch(batch: BatchResultNapi): Promise<void>
  /** Gets the next batch of events for a projection. */
  getProjectionEvents(projectionName: string, batchSize: number): Promise<EventBatchNapi | null>
  /** Gets the current checkpoint for a projection. */
  getProjectionCheckpoint(projectionName: string): Promise<number | null>
  /**
   * Deletes all projection data for a tenant (GDPR compliance).
   *
   * This is called when a tenant or user is deleted to cascade the deletion
   * to all their data in projections. Returns the number of rows deleted.
   *
   * @param projectionName - Name of the projection to delete from
   * @param tenantId - Tenant ID whose data should be deleted
   * @returns number - Count of rows deleted
   */
  deleteTenantFromProjection(projectionName: string, tenantId: string): Promise<number>
  /**
   * Gets current admission control metrics.
   *
   * Returns a snapshot of the adaptive admission control system's state,
   * useful for monitoring and debugging performance issues.
   *
   * @returns AdmissionMetricsNapi - current admission metrics snapshot
   */
  getAdmissionMetrics(): AdmissionMetricsNapi
}
/** NAPI wrapper for the telemetry store. */
export declare class TelemetryDbNapi {
  /** Opens (or creates) a telemetry store under the given root directory. */
  static open(root: string, config?: TelemetryConfigNapi | undefined | null): Promise<TelemetryDbNapi>
  /** Writes a single telemetry record. */
  write(record: TelemetryRecordNapi): Promise<void>
  /** Writes multiple telemetry records. */
  writeBatch(records: Array<TelemetryRecordNapi>): Promise<void>
  /** Flushes all telemetry writers. */
  flush(): Promise<void>
  /** Queries telemetry records. */
  query(query: TelemetryQueryNapi): Promise<Array<TelemetryRecordNapi>>
  /** Tails a specific shard starting from a cursor. */
  tail(cursor: TelemetryCursorNapi, limit: number): Promise<TelemetryTailResultNapi>
  /** Drops telemetry slices older than the retention window. */
  cleanupRetention(): Promise<void>
}
